"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
exports.__esModule = true;
exports.applyAnnotations = exports.makeAnnotator = exports.isAnnotations = void 0;
var accessDeep_1 = require("./accessDeep");
var is_1 = require("./is");
var transformer_1 = require("./transformer");
var pathtree_1 = require("./pathtree");
function isAnnotations(object) {
    try {
        if (object.values) {
            if (!pathtree_1.PathTree.isMinimizedTree(object.values, transformer_1.isTypeAnnotation)) {
                return false;
            }
        }
        if (object.referentialEqualities) {
            if (!pathtree_1.PathTree.isMinimizedTree(object.referentialEqualities, function (tree) {
                return pathtree_1.PathTree.isMinimizedTree(tree, is_1.isString);
            })) {
                return false;
            }
        }
        return true;
    }
    catch (error) {
        return false;
    }
}
exports.isAnnotations = isAnnotations;
var ValueAnnotationFactory = /** @class */ (function () {
    function ValueAnnotationFactory() {
        this.tree = pathtree_1.PathTree.create(null);
    }
    ValueAnnotationFactory.prototype.add = function (path, annotation) {
        pathtree_1.PathTree.append(this.tree, path, annotation);
    };
    ValueAnnotationFactory.prototype.create = function () {
        pathtree_1.PathTree.compress(this.tree);
        return pathtree_1.PathTree.collapseRoot(this.tree);
    };
    return ValueAnnotationFactory;
}());
var ReferentialEqualityAnnotationFactory = /** @class */ (function () {
    function ReferentialEqualityAnnotationFactory() {
        this.objectIdentities = new Map();
    }
    ReferentialEqualityAnnotationFactory.prototype.register = function (object, path) {
        var _a;
        var paths = (_a = this.objectIdentities.get(object)) !== null && _a !== void 0 ? _a : [];
        paths.push(path);
        this.objectIdentities.set(object, paths);
    };
    ReferentialEqualityAnnotationFactory.prototype.create = function () {
        var tree = pathtree_1.PathTree.create(null);
        this.objectIdentities.forEach(function (paths) {
            if (paths.length <= 1) {
                return;
            }
            var _a = __read(paths
                .map(function (path) { return path.map(String); })
                .sort(function (a, b) { return a.length - b.length; })), shortestPath = _a[0], identicalPaths = _a.slice(1);
            var identities = pathtree_1.PathTree.create(null);
            identicalPaths.forEach(function (identicalPath) {
                pathtree_1.PathTree.appendPath(identities, identicalPath);
            });
            var minimizedIdentities = pathtree_1.PathTree.collapseRoot(identities);
            if (!minimizedIdentities) {
                throw new Error('Illegal State');
            }
            pathtree_1.PathTree.append(tree, shortestPath, minimizedIdentities);
        });
        return pathtree_1.PathTree.collapseRoot(tree);
    };
    return ReferentialEqualityAnnotationFactory;
}());
var AnnotationFactory = /** @class */ (function () {
    function AnnotationFactory() {
        this.valueAnnotations = new ValueAnnotationFactory();
        this.objectIdentities = new ReferentialEqualityAnnotationFactory();
    }
    AnnotationFactory.prototype.create = function () {
        var annotations = {};
        var values = this.valueAnnotations.create();
        if (values) {
            annotations.values = values;
        }
        var referentialEqualities = this.objectIdentities.create();
        if (referentialEqualities) {
            annotations.referentialEqualities = referentialEqualities;
        }
        return annotations;
    };
    return AnnotationFactory;
}());
var makeAnnotator = function () {
    var annotationFactory = new AnnotationFactory();
    var valueAnnotations = annotationFactory.valueAnnotations, objectIdentities = annotationFactory.objectIdentities;
    var annotator = function (_a) {
        var path = _a.path, node = _a.node;
        if (!is_1.isPrimitive(node)) {
            objectIdentities.register(node, path);
        }
        var transformed = transformer_1.transformValue(node);
        if (transformed) {
            valueAnnotations.add(path, transformed.type);
            return transformed.value;
        }
        else {
            return node;
        }
    };
    return { getAnnotations: function () { return annotationFactory.create(); }, annotator: annotator };
};
exports.makeAnnotator = makeAnnotator;
var applyAnnotations = function (plain, annotations) {
    if (annotations.values) {
        pathtree_1.PathTree.traverseWhileIgnoringNullRoot(pathtree_1.PathTree.expandRoot(annotations.values), function (type, path) {
            plain = accessDeep_1.setDeep(plain, path, function (v) { return transformer_1.untransformValue(v, type); });
        });
    }
    if (annotations.referentialEqualities) {
        pathtree_1.PathTree.traverseWhileIgnoringNullRoot(pathtree_1.PathTree.expandRoot(annotations.referentialEqualities), function (identicalObjects, path) {
            var object = accessDeep_1.getDeep(plain, path);
            pathtree_1.PathTree.traversePaths(pathtree_1.PathTree.expandRoot(identicalObjects), function (identicalObjectPath) {
                plain = accessDeep_1.setDeep(plain, identicalObjectPath, function () { return object; });
            });
        });
    }
    return plain;
};
exports.applyAnnotations = applyAnnotations;
//# sourceMappingURL=annotator.js.map