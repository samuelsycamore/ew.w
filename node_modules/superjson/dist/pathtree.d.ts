export declare type Tree<T> = InnerNode<T> | Leaf<T>;
declare type Leaf<T> = [T];
declare type InnerNode<T> = [T, Record<string, Tree<T>>];
export declare function isTree<T>(v: any, valueChecker: (nodeValue: T) => boolean): v is Tree<T>;
export declare module PathTree {
    function create<T>(value: T): Tree<T>;
    function get<T>(tree: Tree<T>, path: string[]): [T, true] | [null, false];
    /**
     * @description Optimised for adding new leaves. Does not support adding inner nodes.
     */
    function append<T>(tree: Tree<T>, path: string[], value: T): void;
    function appendPath(tree: Tree<string | null>, path: string[]): void;
    /**
     * Depth-first post-order traversal.
     */
    function traverse<T>(tree: Tree<T>, walker: (v: T, path: string[]) => void, origin?: string[]): void;
    function traverseWhileIgnoringNullRoot<T>(tree: Tree<T | null>, walker: (v: T, path: string[]) => void): void;
    function traversePaths(tree: Tree<string | null>, walker: (path: string[]) => void): void;
    type CollapsedRootTree<T> = Tree<T> | Record<string, Tree<T>> | undefined;
    function isMinimizedTree<T>(v: any, valueChecker: (v: T) => boolean): v is CollapsedRootTree<T>;
    /**
     * @description Minimizes trees that start with a `null`-root
     */
    function collapseRoot<T>(tree: Tree<T | null>): CollapsedRootTree<T>;
    function expandRoot<T>(tree: CollapsedRootTree<T>): Tree<T | null>;
    /**
     * @description Compress nested trees for smaller output
     */
    function compress<T>(tree: Tree<T | null>): void;
}
export {};
