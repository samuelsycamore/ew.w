"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
exports.__esModule = true;
exports.PathTree = exports.isTree = void 0;
var pathstringifier_1 = require("./pathstringifier");
var is_1 = require("./is");
var util_1 = require("./util");
function isTree(v, valueChecker) {
    if (!is_1.isArray(v)) {
        return false;
    }
    if (v.length === 1) {
        return valueChecker(v[0]);
    }
    else if (v.length === 2) {
        return valueChecker(v[0]) && util_1.every(v[1], function (v) { return isTree(v, valueChecker); });
    }
    return false;
}
exports.isTree = isTree;
var PathTree;
(function (PathTree) {
    function create(value) {
        return [value];
    }
    PathTree.create = create;
    function get(tree, path) {
        if (path.length === 0) {
            return [tree[0], true];
        }
        if (tree.length === 1) {
            return [null, false];
        }
        else {
            var _a = __read(path), head = _a[0], tail = _a.slice(1);
            var _b = __read(tree, 2), children = _b[1];
            return get(children[head], tail);
        }
    }
    PathTree.get = get;
    /**
     * @description Optimised for adding new leaves. Does not support adding inner nodes.
     */
    function append(tree, path, value) {
        var _a;
        if (path.length === 0) {
            tree[0] = value;
            return;
        }
        if (tree.length === 1) {
            tree[1] = (_a = {}, _a[pathstringifier_1.stringifyPath(path)] = [value], _a);
        }
        else {
            tree[1][pathstringifier_1.stringifyPath(path)] = [value];
        }
    }
    PathTree.append = append;
    function appendPath(tree, path) {
        var front = path.slice(0, path.length - 1);
        var last = path[path.length - 1];
        append(tree, front, last);
    }
    PathTree.appendPath = appendPath;
    /**
     * Depth-first post-order traversal.
     */
    function traverse(tree, walker, origin) {
        if (origin === void 0) { origin = []; }
        if (tree.length === 1) {
            var _a = __read(tree, 1), nodeValue = _a[0];
            walker(nodeValue, origin);
        }
        else {
            var _b = __read(tree, 2), nodeValue = _b[0], children = _b[1];
            util_1.forEach(children, function (child, key) {
                traverse(child, walker, __spread(origin, pathstringifier_1.parsePath(key)));
            });
            walker(nodeValue, origin);
        }
    }
    PathTree.traverse = traverse;
    function traverseWhileIgnoringNullRoot(tree, walker) {
        traverse(tree, function (v, path) {
            if (is_1.isNull(v)) {
                if (path.length === 0) {
                    return;
                }
                throw new Error('Illegal State');
            }
            walker(v, path);
        });
    }
    PathTree.traverseWhileIgnoringNullRoot = traverseWhileIgnoringNullRoot;
    function traversePaths(tree, walker) {
        traverseWhileIgnoringNullRoot(tree, function (last, front) {
            return walker(__spread(front, [last]));
        });
    }
    PathTree.traversePaths = traversePaths;
    function isMinimizedTree(v, valueChecker) {
        if (is_1.isUndefined(v)) {
            return true;
        }
        if (is_1.isPlainObject(v)) {
            return util_1.every(v, function (v) { return isTree(v, valueChecker); });
        }
        return isTree(v, valueChecker);
    }
    PathTree.isMinimizedTree = isMinimizedTree;
    /**
     * @description Minimizes trees that start with a `null`-root
     */
    function collapseRoot(tree) {
        if (is_1.isNull(tree[0])) {
            if (tree.length === 1) {
                return undefined;
            }
            else {
                return tree[1];
            }
        }
        return tree;
    }
    PathTree.collapseRoot = collapseRoot;
    function expandRoot(tree) {
        if (is_1.isArray(tree)) {
            return tree;
        }
        if (is_1.isUndefined(tree)) {
            return [null];
        }
        return [null, tree];
    }
    PathTree.expandRoot = expandRoot;
    /**
     * @description Compress nested trees for smaller output
     */
    function compress(tree) {
        var _a;
        if (tree.length === 1) {
            // tree root is Leaf
            return;
        }
        var origin = tree[1];
        var keys = Object.keys(origin).sort(function (a, b) { return a.length - b.length; });
        var transformed = {};
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var parentKey = undefined;
            var splittedKey = key.split('.');
            while (splittedKey.length > 0) {
                splittedKey.pop();
                var possibleParentKey = splittedKey.join('.');
                if (transformed.hasOwnProperty(possibleParentKey)) {
                    parentKey = possibleParentKey;
                    break;
                }
            }
            if (parentKey && transformed[parentKey]) {
                transformed[parentKey][1] = Object.assign(transformed[parentKey][1] || {}, (_a = {},
                    _a[key.substring(parentKey.length + 1)] = origin[key],
                    _a));
                continue;
            }
            else {
                transformed[key] = origin[key];
            }
        }
        // Recursive optimization
        var transformedKeys = Object.keys(transformed);
        for (var i = 0; i < transformedKeys.length; i++) {
            compress(transformed[transformedKeys[i]]);
        }
        tree[1] = transformed;
    }
    PathTree.compress = compress;
})(PathTree = exports.PathTree || (exports.PathTree = {}));
//# sourceMappingURL=pathtree.js.map